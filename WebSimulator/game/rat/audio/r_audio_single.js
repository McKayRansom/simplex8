//
//	A strange variant audio implementation:
//		A single shared sound is loaded
//		we play segments of this sound as if they were individual sounds.
//		we only support playing one such segment at a time.
//	This is useful for PS4 Browser.
//
/*
	Why is this needed for PS4 Browser?
		Because after extensive research and experimentation, it became clear that the PS4's browser
		(as it currently stands as of Fall 2014) only supports playing the last sound loaded.
		When you load a sound, any previous sounds are immediately invalidated.
*/
//	The current way this works is we load and init this module after the normal r_audio implementation,
//		and we replace that one entirely with this one.
//	Strange?  Maybe, but our dynamic load system doesn't distinguish between platforms yet,
//		and this is a quick way to implement this using some functionality of r_audio without having a class hierarchy or something.
//		Though, now I feel really lazy.  I should rewrite rat.audio to be a base class.
//
rat.modules.add( "rat.audio.r_audio_single",
[
	{name: "rat.os.r_system", processBefore: true},
	{name: "rat.audio.r_audio", processBefore: true},
	"rat.debug.r_console",
], 
function(rat)
{
	//	Only build this system for PS4
	if (!rat.system.has.PS4Browser)
		return;
		
	var singleAudio = {	//	audio namespace
		initialized : false,
		soundOn: true,
		isSingleAudio : true,
		
		sharedSound : null,
		curSound : null,
		curSoundID : '',
		
		sounds: {},	//	hashtable of sound info, always accessed by literal sound ID (string)

		//	music : [],

		/**
		 *@suppress {undefinedVars} - Don't warn about undefined Audio, as it is defined
		 */
		audioConstructor: function ()
		{
			return new Audio();
		},

		init : function()
		{
			//	just piggy-back on rat.audio init function already defined
			rat.baseAudio.init(singleAudio);
		},
		
		//	one-time system-level preload of a shared resource that all sounds will play out of.
		//	This is slightly insane, but needed by the very weak PS4 browser.  This combines with a per-sound "offset" value,
		//	and one-at-a-time sound playback.
		//	"offsetTable" is a data block (presumably generated by the same tool that built the concatenated shared file)
		//	that specifies where each subsound is in this master shared sound.
		//	see rtest audio sample
		useSharedResource: function (resource, offsetTable)
		{
			console.log("Setting up single shared sound " + resource);
			var a = singleAudio.audioConstructor();
			a.preload = 'auto';
			//a.addEventListener('canplaythrough', on_load, false);
			//a.addEventListener('stalled', on_stalled, false);
			//a.addEventListener('error', on_error, false);
			a.src = resource;
			//	not needed?
			a.load();
			singleAudio.sharedSound = a;
			singleAudio.offsetTable = offsetTable;
		},

		//	Load (preload) sounds into the audio system.
		//	Same format as in r_audio
		//	This is hugely copied and pasted from r_audio.  :(  Not sure how to refactor this...
		loadSounds: function (sounds)
		{
			if (!singleAudio.offsetTable)
			{
				console.log("In order to load sounds using audio_single, you must first call rat.audio.useSharedResource(). (PS4)");
				return;
			}
			
			function loadTrigger(res, entry)
			{
				//	don't load anything, man...
				//	just build an object to track in our list of sounds (list of lists, really).
				//	Here is where we need to look up the sound's offset...
				//	Let's use the original name, since from the client's point of view, that's what they specified...
				var offEntry = singleAudio.offsetTable[entry.resource];
				if (!offEntry)
				{
					console.log("couldn't find shared sound " + entry.resource);
					return null;	//	no such sound - don't load it.
				}
					
				var sound = {
					res:res,
					volume:entry.volume,
					soundInfo:entry,	//	original entry
					offsetInfo:offEntry,	//	offset position/duration
				};
				return sound;
			}
			
			//	use rat's audio loader code
			singleAudio.sounds = rat.baseAudio.loadSoundList(sounds, loadTrigger);
			
		},	//	end of loadSounds function
		
		//	internal utility to set current (only) sound
		setCurrentSound : function(soundID, pickRandom)
		{
			var sound = rat.baseAudio.selectSound(soundID);
			if (!sound)
			{
				singleAudio.curSoundID = '';
				singleAudio.curSound = null;
				return null;
			}
			
			singleAudio.curSoundID = soundID;
			singleAudio.curSound = sound;
			
			return sound;
		},
		
		//	play a sound.
		//	In this implementation, this means skipping to the place where our sound lives.
		playSound: function (soundID)
		{
			//	todo:  refactor this into "pick sound" function
			
			var sound = singleAudio.setCurrentSound(soundID);
			if (!sound)
				return;
			
			var offset = sound.offsetInfo.offset;
			singleAudio.sharedSound.pause();
			singleAudio.sharedSound.currentTime = offset;
			singleAudio.sharedSound.play();
		},

		pauseSound: function (soundID)
		{
			//	assume it's the current sound
			singleAudio.sharedSound.pause();
		},

		// returns a sound to the starting position
		resetSound: function (soundID)
		{
			//	assume it's the current sound
			if (!singleAudio.curSound)
				return;
			singleAudio.sharedSound.currentTime = singleAudio.curSound.offsetInfo.offset;
		},

		//	stop and reset a sound to starting position
		stopSound: function (soundID)
		{
			singleAudio.pauseSound(soundID);
			singleAudio.resetSound(soundID);
		},
		
		//	seek sound to a certain point
		//	TODO:  Make it so that subsequent playSound plays from this point!
		//	see r_audio_test_screen, which calls seekSound and then playSound, which isn't currently working.
		seekSound: function (soundID, toWhence, isNormalized)
		{
			var sound = singleAudio.setCurrentSound(soundID);
			if (!sound)
				return;
				
			if (typeof(isNormalized) === 'undefined')
				isNormalized = false;
			
			var dur = sound.offsetInfo.duration;
			var target = toWhence;
			if (isNormalized)
				target *= dur;
			target += sound.offsetInfo.offset;
			
			singleAudio.sharedSound.currentTime = target;
		},
		
		getSoundVolume: function (soundID)
		{
			var sound = rat.baseAudio.selectSound(soundID);
			if (!sound)
				return 0;
			else
				return sound.volume;
		},
		
		setSoundVolume: function (soundID, volume)
		{
			
			var sound = rat.baseAudio.selectSound(soundID);
			sound.volume = volume;
			
			if (singleAudio.curSoundID === soundID)
				singleAudio.sharedSound.volume = volume;
		},

		//	do regular maintenance
		update: function (dt)
		{
			//	here we need to manually check our playback and stop it when it goes past the end of one segment in the shared sound.
			if (singleAudio.curSound)
			{
				if (singleAudio.sharedSound.currentTime > singleAudio.curSound.offsetInfo.offset + singleAudio.curSound.offsetInfo.duration)
				{
					singleAudio.stopSound(singleAudio.curSoundID);
				}
			}
		},

		//	how many sounds are registered?  mostly for debug?
		getSoundCount: function ()
		{
			return rat.baseAudio.getSoundCount();
		},

		//	get nth sound (mostly for debug?)
		getSoundIDByIndex: function (index)
		{
			return rat.baseAudio.getSoundIDByIndex(index);
		},

		//	get internal info - mostly debug? should probably not depend on this internal structure staying the same.
		//	OR, it should be well documented and standard that this info will stay the same.
		getSoundInfo: function (id)
		{
			var entry = rat.audio.sounds[id];
			if (entry && entry[0])
			{
				var first = entry[0];
				var currentTime = 0;
				if (singleAudio.curSoundID === id)
				{
					currentTime = singleAudio.sharedSound.currentTime - singleAudio.curSound.offsetInfo.offset;
				}
				var info = {
					id: id,
					duration: first.offsetInfo.duration,
					source: first.res,
					volume: first.volume,
					currentPos: currentTime,
					readyState: singleAudio.sharedSound.readyState,
					errorCode: 'none',
				};
				
				if (singleAudio.sharedSound.error)
					info.errorCode = singleAudio.sharedSound.error.code;

				return info;
			} else
			{
				//rat.console.log("Requested info for nonexistent sound" + id);
				return {
					id: 'NO SUCH ID',
					duration : 0,
					source : 'NO SUCH',
					volume: 0,
					currentPos : 0,
					readyState : '',
					errorCode : 'none',
				};
			}
		},

		//	whatever
		isSoundLoaded: function (id)
		{
			return true;
		},

		//	return true if all sounds listed in cache are loaded
		isCacheLoaded: function ()
		{
			return true;	//	todo:  track our single shared sound
		},

		//	is this sound actively playing?
		isSoundPlaying: function (id)
		{
			var entry = rat.audio.sounds[id];
			if (entry)
			{
				var first = entry[0];
				//console.log("cp " + first.currentTime);
				if (first.currentTime > 0 && first.currentTime < first.duration)
					return true;
			}
			return false;
		},

		//	what sound listed in cache is not loaded?  mostly debug.
		whatIsMissing: function ()
		{
			rat.console.log("not implemented");
		},

	};
	
	//	This whole module will replace rat.audio (only if we're on PS4 - see above)
	//	Ugh, this is getting more and more kludgey.  Need classes...
	rat.baseAudio = rat.audio;
	rat.audio = singleAudio;
	rat.audio.loadSoundList = rat.baseAudio.loadSoundList;

	// called from system init now...  rat.audio.init();
} );

