
//	global simulation class

Simulation = function()
{
	//essential the PC (program counter)
	this.nextInstruction = 0;

	//current state of all flags (for conditional jumps)
	this.flags = [
		false, //EQUALS
		false, //LT
		false, //GT
		false, //OVERFLOW
		false, //input???
		false, //any
		false, //shiftOverflow
	]

	//map of inputs (Simulating IO)
	this.inputs = [
		true,
		false,
		false,
		false,
		false,
	]
	
	//the name of the current instruction for display next to the current line.
	this.name = "NOOP"

	//a list of instruction names to generate the above
	this.instructionNames = {
		'0': 'NOOP',
		'1': 'LI',
		'2' :'UI',
		'3' :'MOVE',
		'4' :'ACC',
		'5' :'ADD',
		'6' :'SUB',
		'7' :'EQUAL',
		'8' :'SHIFT',
		'9' :'AND',
		'a' :'OR',
		'b' :'JMP',
		'c' :'STORE',
		'd' :'LOAD',
		'e' :'DISP',
		'f' :'INPUT'
	}

	//input map
	this.keys = {
		"ArrowUp": 3,
		"ArrowDown": 4,
		"w": 1,
		"s": 2
	}

	//register values
	this.registers = [
		0, 0, 0, 0,
		0, 0, 0, 0,
		0, 0, 0, 0,
		0, 0, 0, 0
	];
	
	//display emulation
	this.display = {
	'1' : [0, 0, 0, 0, 0, 0, 0, 0],
	'2' : [0, 0, 0, 0, 0, 0, 0, 0],
	'4' :	[0, 0, 0, 0, 0, 0, 0, 0],
	'8' :	[0, 0, 0, 0, 0, 0, 0, 0],
	'16' :	[0, 0, 0, 0, 0, 0, 0, 0],
	'32' :	[0, 0, 0, 0, 0, 0, 0, 0],
	'64' :	[0, 0, 0, 0, 0, 0, 0, 0],
	'128' :	[0, 0, 0, 0, 0, 0, 0, 0]
	}

	//this determines how long dots on the display linger. AN attempt to fix display problems...
	this.displayLinger = .4;

	//program memory
	this.memory = new Array(256);
	for (var i = 0; i < this.memory.length; i++)
	{
		this.memory[i] = 0;
	}
	//this.memory[0] = 0;
	//this.memory[1] = 0;

}

//placeholder instructions Instructions should be overwritten by 'instructions.js' generated by the assembler
Simulation.prototype.instructions = ['00', '00', '00']

// function to convert from hex to decimal
Simulation.prototype.fromHex = function(toConvert) {
	var hexLookup = {
		'0': 0,
		'1': 1,
		'2' : 2,
		'3' : 3,
		'4' : 4,
		'5' :5,
		'6' :6,
		'7' :7,
		'8' :8,
		'9' :9,
		'a' :10,
		'b' :11,
		'c' :12,
		'd':13,
		'e' :14,
		'f' :15
	}
	return hexLookup[toConvert]
}

//function to convert to hex from decimal
Simulation.prototype.toHex = function(decimalNumber) {
	var lookupTable = {
		"10": "a",
		"11": "b",
		"12": "c",
		"13": "d",
		"14": "e",
		"15": "f"
	}
	var numberString= decimalNumber.toString();
	//return this.toHex(Math.floor(decimalNumber/16)) + this.toHex(decimalNumber % 16);
	if (Math.floor(decimalNumber / 16) > 0) {
		//fix this someday
	} else if (decimalNumber < 10) {
		return decimalNumber.toString();
	} else {
		return lookupTable[decimalNumber];
	}
}


//WOW! this is SUPER COOL!!! 
//converts from a decimal to a binary array
Simulation.prototype.toBinaryArray = function(decimal) {
	var binaryArray = [0, 0, 0, 0, 0, 0, 0, 0]
	for (var i = 0; i < 8; i++) {
		binaryArray[i] = decimal % 2;
		decimal = Math.floor(decimal / 2 )
	}
	return binaryArray;
}

Simulation.prototype.simulateDisplay = function(row, column) {
	var array = this.toBinaryArray(row);
	this.display[column] = array;

	// this.display[this.registers[0]][this.registers[immediate]] = 1;
	// if (this.previousLED) {
		// this.display[this.previousLED.row][this.previousLED.column] = this.displayLinger;
	// }
	// this.previousLED = {
		// row: this.registers[0],
		// column: this.registers[immediate]
	// }
}

Simulation.prototype.testJumpCondition = function(condition) {
	if (condition == 0) {
		return true;
	} else if (condition < 8) {
		return this.flags[condition - 1]
	} else {
		return !this.flags[condition - 9]
	}
	return false;
}

//set flags after an arithmetic function.
Simulation.prototype.setFlags = function(immediate) {
	var EQUALS = 0;
	var OVERFLOW = 3;
	var INPUT = 4;
	var AND = 5;
	if (this.registers[0] == this.registers[immediate]) {
		this.flags[EQUALS] = true;
	} else {
		this.flags[EQUALS] = false;
	}
	var a = this.toBinaryArray(this.registers[0]);
	var b = this.toBinaryArray(this.registers[immediate]);
	this.flags[AND] = false;
	for ( var i = 0; i < 8; i++) {
		if ( a[i] && b[i]) {
			this.flags[AND] = true;
			break;
		}
	}
	if (this.registers[0] > 255) {
		this.registers[0] = this.registers[0] & 255;
		this.flags[OVERFLOW] = true;
	} else {
		this.flags[OVERFLOW] = false;
	}
}

//	simulate display system by reading display-directed memory settings.
//	I've separated this from updateDisplay so we can run THIS one a lot per frame
//	and let updateDisplay only update once every frame
//	TODO: optimize how we're storing memory here - we're calling this tens of thousands of times
//	per frame, under normal conditions, which we SHOULD, because any given instruction (tick)
//	could be trying to write to the display!
//	But I don't really understand how this is being done, so I'm hesitant to change it yet.  :)
//	(2017.2.2 STT)
//	TODO: only call this when an instruction could be changing memory?
//	like a store?
//	OR, to effectively simulate actual video system, figure out how often it does this equivalent?
//	Is it on the same clock cycle?
Simulation.prototype.mapDisplay = function() {
	if (this.memory[0] > 0) {
		//take the current output to the display and display it
		this.display[this.memory[0].toString()] = this.toBinaryArray(this.memory[1]);
	}
};

Simulation.prototype.updateDisplay = function(dt) {	
	//go through each row
	for (var row = 1; row < 129; row *= 2) {
		//go through each column
		for (var column = 0; column < 8; column++) {
			//each position contains a number, this is how long until we turn it off.
			//this way each dot 'lingers' for a second before disapearing
			row = row.toString()
			if (this.display[row][column] > 0 && this.display[row][column] < 1) {
				this.display[row][column] -= dt;
			} else if (this.display[row][column] == 1) {
				this.display[row][column] = this.displayLinger;
			}
		}
	}
};

//run one machine cycle
Simulation.prototype.tick = function() {
	
	//get next instruction
	var instruction = this.instructions[this.nextInstruction];
	//	trying to tick when we're already at end?  don't do that.
	if (!instruction) {
		//finished execution
		return true;
	}

	var opCode = instruction.substr(0, 1);
	var immediate = this.fromHex(instruction.substr(1, 1))
	this.nextInstruction++;
	switch (opCode) {

		case "0": //NOOP
			break;
		case "1": //LI
			this.registers[0] = Math.floor(this.registers[0] / 16) * 16 + immediate;
			break;
		case "2": //UI
			this.registers[0] = (this.registers[0] % 16) + (immediate * 16);
			break;
		case "3": //MOVE
			this.registers[immediate] = this.registers[0];
			break;
			break;
		case "4": //ACC
			this.registers[0] = this.registers[immediate];
			break;
		case "5": //ADD
			this.registers[0] = this.registers[0] + this.registers[immediate];
			this.setFlags(immediate);
			break;
		case "6": //SUB
			this.registers[0] = -this.registers[0] + this.registers[immediate];
			this.setFlags(immediate);
			break;
		case "7": //EQUAL
			break;
		case "8": //SHIFT
			if (this.registers[0] % 2 == 1) {
				this.flags[6] = true
			} else {
				this.flags[6] = false
			}
			this.registers[0] = Math.floor(this.registers[0] / 2)
			this.setFlags(immediate);
			break;
		case "9": //AND
			this.setFlags(immediate);
			this.registers[0] = this.registers[0] & this.registers[immediate];

			break;
		case "a": //OR
			this.setFlags(immediate);
			this.registers[0] = this.registers[0] | this.registers[immediate];
			break;
		case "b": //JMP
			//no condition:
			if (this.testJumpCondition(immediate)) {
				this.nextInstruction = this.registers[0] + this.registers[1] * 256;
			}
			break;
		case "c": //STORE
			this.memory[this.registers[0]] = this.registers[immediate];
			//	STT - this is the only case where display can change, so set it right now.
			if (this.registers[0] === 0 || this.registers[0] === 1)
				this.mapDisplay();
			break;
		case "d": //LOAD
			if (!(this.registers[0] == 4)) {
				this.registers[immediate] = this.memory[this.registers[0]];
			} else {
				//we are accessing memory mapped input so simulate that
				this.registers[immediate] = 0;
				for (var i = 1; i < 5; i++) {
					if (this.inputs[i]) {
						this.registers[immediate] += Math.pow(2, (i-1));
					}
				}
			}
			break;
		case "e": //DISP REMOVED
			//this.simulateDisplay(this.registers[0], this.registers[immediate]);
			break;
		case "f": //INPUT REMOVED
			// if (this.inputs[immediate]) {
			// 	this.flags[INPUT] = true;
			// } else {
			// 	this.flags[INPUT] = false;
			// }
			break;
		default:
	}
	var nextInstr = this.instructions[this.nextInstruction]
	if (!nextInstr) {
		//finished execution
		return true;
	}
	//update the instruction name (to be displayed next to the current line)
	this.name = this.getInstructionName(nextInstr);
	return false;
}

Simulation.prototype.getInstructionName = function(instr)
{
	return this.instructionNames[instr.substr(0,1)] + " " + instr.substr(1,1);
}

Simulation.prototype.handleKeyDown = function(key) {
	if (this.keys[key]) {
		this.inputs[this.keys[key]] = true;
	}
}

Simulation.prototype.handleKeyUp = function(key) {
	if (this.keys[key]) {
		this.inputs[this.keys[key]] = false;
	}
};
